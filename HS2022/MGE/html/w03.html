<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <title>w03</title>
  </head>
  <body class="typora-export os-windows">
    <div class="typora-export-content">
      <div id="write" class="">
        <h1 id="android-gui-programmierung">
          <span>Android GUI Programmierung</span>
        </h1>
        <p>
          <span
            >Zwei Arten zur Darstellung des GUI: Beschreibung im XML vs.
            Quellcode (Java oder Kotlin)</span
          >
        </p>
        <h2 id="views-und-view-groups-auch-layouts-containers">
          <span>Views und View Groups (auch Layouts, Containers)</span>
        </h2>
        <p>
          <span
            >Stellen einen hierarchischen Baum dar, nach Composite Design
            Pattern. </span
          ><strong><span>View</span></strong
          ><span>
            ist Basisklasse aller GUI Elemente. Aufgaben: Darstellung und
            Event-Verarbeitung. </span
          ><strong><span>ViewGroup</span></strong
          ><span>
            dient der Anordnung von Kindern nach einem Muster. Ist
            strukturierend aber selber unsichtbar. Verschachtelung ist beliebig
            möglich, aber immer eine Performancefrage.</span
          >
          <strong><span>Einfache Layouts</span></strong
          ><span> sind LinearLayout, RelativeLayout, </span
          ><em><span>ConstraintLayout</span></em
          ><span>, </span><strong><span>AdapterLayouts</span></strong
          ><span> sind ListView, GridView, </span
          ><em><span>RecyclerView</span></em
          ><span> (Google empfiehlt).</span>
          <span>Höhe und Breite müssen zwingend definiert sein. </span
          ><code>layout_width</code><span> und </span><code>layout_height</code
          ><span> (immer nur &quot;ein Wunsch&quot;) mit entweder </span
          ><code>wrap_content</code><span> oder </span><code>match_parent</code
          ><span>
            (kann über einen Screen hinausgehen). Jede Eigenschaft mit </span
          ><strong><span>Präfix &quot;_layout&quot;</span></strong
          ><span> dient als Wunsch an das Elternelement (</span
          ><code>layout_width, layout_height, layout_margin</code
          ><span>). </span><code>padding</code
          ><span>
            wird auf Element selber gesetzt. Verschiedene Abmessungen pro
            Element: </span
          ><code>getMeasuredWidth/Height(),</code
          ><span> für &quot;Wunsch&quot;, </span><code>getWidth/Height()</code
          ><span> für reale Grösse.</span>
        </p>
        <p>
          <img
            src="C:/git/hsr-documents/HS2022/MGE/res/layout-boxmodel.png"
            referrerpolicy="no-referrer"
          />
        </p>
        <p>
          <strong><span>LinearLayout:</span></strong
          ><span> </span
          ><code>android:orientation=&quot;vertical|horizontal&quot;</code
          ><span> , </span><code>android:layout_weight=&quot;1&quot;</code
          ><span> zur Aufteilung vom restlich verbleibenden Platz. </span
          ><strong><span>FrameLayout</span></strong
          ><span>
            wird für Overlay-Designs verwendet. XML-Reihenfolge oder </span
          ><code>android:translationZ</code
          ><span> bestimmt die Höhe auf Z-Achse. </span
          ><strong><span>RelativeLayout</span></strong
          ><span>
            ordnet Kinder relativ zueinander an. Viele Parameter wie </span
          ><code
            >android:layout_alignParentTop=&quot;true&quot;,
            below=&quot;@id/x&quot;, toStartOf=&quot;@id/x&quot;,
            alignStart=&quot;@id/y&quot;</code
          ><span> (immer mit Layout-Prefix). </span
          ><strong><span>ConstraintLayout</span></strong
          ><span>
            (Jetpack) wurde speziell für komplexe Layouts mit flacher Hierarchie
            entworfen. Constraints definieren &quot;Beziehungen zwischen
            Views&quot;. Minimum 1x horizontal und 1x vertical Constraint.
            Bevorzugt rein visuelles Design in der IDE. Automatische Umwandlung
            in ein Constraint Layout ist möglich. Namespace Import </span
          ><code
            >xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code
          >
          <span>Constraint-Varianten:</span>
        </p>
        <p>
          <img
            src="C:/git/hsr-documents/HS2022/MGE/res/android-constraints.png"
            referrerpolicy="no-referrer"
          />
        </p>
        <p>
          <strong><span>ScrollView</span></strong
          ><span>
            hat nur ein Kind-Element und ergänzt eine vertikale Scrollbar. </span
          ><strong><span>HorizontalScrollView</span></strong
          ><span> für nur horizontal oder Jetpack </span
          ><strong><span>NestedScrollView</span></strong
          ><span> für beides. width/height=match_parent.</span>
        </p>
        <h2 id="adapter-layouts-für-collections">
          <span>Adapter Layouts für Collections</span>
        </h2>
        <p>
          <img
            src="res/android-adapterlayout.png"
            referrerpolicy="no-referrer"
          />
        </p>
        <p>
          <span
            >Anzahl der Elemente ist nicht bekannt, aber die Struktur.
            Collection von Elementen (Daten) muss dargestellt werden via
            Adapter. </span
          ><strong><span>Hint</span></strong
          ><span
            >: Leere Listen vermeiden, Platzhalter verwenden durch
            ein/ausblenden von Elementen. </span
          ><strong><span>View Recycling</span></strong
          ><span>
            lässt die View-Elemente beim Scrollen wiederverwendet werden. Spart
            Arbeitsspeicher bei den anzuzeigenden Elementen und Rechenzeit beim
            enerieren von Views. </span
          ><strong><span>Android Array Adapter</span></strong
          ><span>
            implementiert dies selber schon. Bietet einfache Vorlagen für
            Listitems, die jeweils mit String Arrays verwendet werden können. </span
          ><strong><span>Custom ArrayAdapter:</span></strong
          ><span> Dient der Darstellung von komplexeren Datenklassen </span
          ><code>custom</code
          ><span>
            auf dieselben Listitem-Vorlagen. Eigene Adapterklasse leitet von </span
          ><code>ArrayAdapter&lt;custom&gt;</code
          ><span> ab und überschreibt speziell die Methode </span
          ><code
            >public View getView(int position, View view, ViewGroup
            parent);</code
          ><span
            >. Diese kümmert sich um das Erzeugen und anschliessende
            Wiederverwenden von der nötigen Anzahl Views. Weiter werden von der </span
          ><code>custom</code
          ><span
            >-Klasse dann definiert, welche Felder in welche Textfelder der View
            abgefüllt werden. Der entsprechende Eintrag wird mit </span
          ><code>Custom custom = getItem(pos);</code><span> abgeholt.</span>
          <strong><span>View Holder Pattern:</span></strong
          ><span> Optimieren von </span><code>findViewById</code
          ><span>
            pro dargestelltem Element beim scrollen, Ziel Speichern der
            Objektreferenzen pro erzeugte View. Klasse ViewHolder beinhaltet nur
            die nötigen Referenzen. Nach Erzeugen der View wird das Objekt mit </span
          ><code>view.setTag(viewHolder)</code
          ><span> an die View geknüpft. Abfrage mit </span
          ><code>(ViewHolder)view.getTag();</code><span>.</span>
        </p>
        <p>
          <span>Ergo </span><strong><span>RecyclerView</span></strong
          ><span>
            (Jetpack): ViewRecycling integriert, ViewHolder Verwendung wird
            erzwungen. Weniger Overhead im eigenen Code. Ableitung von Basis </span
          ><code>RecyclerView.Adapter&lt;ViewHolder&gt;</code
          ><span>
            benötigt zwingend eigenen ViewHolder Typen bei Implementierung.
            Weiter ist Überschreiben von 3 Methoden nötig. </span
          ><code>getItemCount()</code
          ><span>
            implementiert, wie viele Objekte in der Liste vorhanden sind. </span
          ><code>onCreateViewHolder(ViewGroup parent, int vt)</code
          ><span>
            erzeugt ViewHolder und generiert Layout, holt Controls ab. Kein
            Erzeugen der Views mehr. </span
          ><code>onBindVewHolder(ViewHolder holder, int position)</code
          ><span>
            füllt die Informationen aus den darzustellenden Listenelementen in
            den ViewHolder ab.</span
          >
        </p>
        <h2 id="controls-widgets"><span>Controls (Widgets)</span></h2>
        <p>
          <span>Namespace </span><code>android.widget</code
          ><span>. Sammelbegriff für visuelle Elemente. Basisklasse ist </span
          ><code>View</code><span> (nicht Widget). </span
          ><strong><span>TextView</span></strong
          ><span>: viele Format Attribute, integrierte Bilder (</span
          ><code>android:drawable[Start|End]</code
          ><span>), Listener möglich. </span
          ><code>beforeTextChanged, onTextChanged, afterTextChanged</code
          ><span>
            sind mögl. Callbacks zum Handling von Events. Besser einfach
            halten.. </span
          ><strong><span>ImageView</span></strong
          ><span>: Bilder. Mögli. Parameter: </span
          ><code>android:src, android:scaleType, android:tint</code
          ><span>. </span><strong><span>Button und ImageButton</span></strong
          ><span
            >: lösen Aktionen via Listener aus. Ableitung von
            TextView/ImgageView. StandardStyling je nach OS Version. </span
          ><strong><span>EditText</span></strong
          ><span>: Eingabefeld für Texte und Zahlen. Parameter </span
          ><code>android:inputType</code
          ><span>
            steuert Typ und angezeigte Tastatur, Korrekturoptionen, Darstellung,
            Mehrzeiligkeit. Kombination mit </span
          ><code>android:inputType=&quot;param1|param2&quot;</code
          ><span>. </span><code>inputField.setError()</code
          ><span>
            für Validierung, wird nach jeder Änderung zurückgesetzt. Fehlericon
            bei Bedarf anpassbar.</span
          >
          <strong><span>Weitere Controls</span></strong
          ><span
            >: Checkboxes, Picker, Floating Action Button, Radio Buttons,
            Switches, Seek Bar, Rating Bar, Spinner...
          </span>
        </p>
        <h3 id="controls-ohne-xml"><span>Controls ohne XML</span></h3>
        <p>
          <span
            >Layout von Android vorgegeben, übergeben werden nur einzelne
            Parameter. Bsp: Fehlermeldungen. </span
          ><strong><span>Toasts:</span></strong
          ><span>
            Einfache Rückmeldung im Popup Fenster, keine Benutzerinteraktion.
            Position und Layout anpassbar. </span
          ><strong><span>Snackbars:</span></strong
          ><span> Jetpack-Variante f. Toast, Benutzerinteraktion möglich. </span
          ><strong><span>Dialoge:</span></strong
          ><span>
            Antwort von Benutzer zwingend. Anpassen von Titel, Inhalt, Buttons,
            ... </span
          ><strong><span>Notifications:</span></strong
          ><span>
            Mitteilungen ausserhalb aktiver Nutzung. Anpassen von Dringlichkeit,
            Darstellung, Gruppierung. Darstellung mögl. in Statusbar,
            Notification Drawer, Heads-Up Notif., Lock Screen, App Icon Badge. </span
          ><code>NotificationCompat</code><span> aus Jetpack verwenden. </span
          ><strong><span>Menus</span></strong
          ><span
            >: Options Menu in Appbar (Hamburger Icon), Contextual Menu
            (Floating oder in einer ContextActionBar), Popup Menu. Resource in </span
          ><code>res/menu</code
          ><span>
            definiert Inhalt, Handlung der Auswahl innerhalb Activity. Jetpack
            verwenden.</span
          >
        </p>
        <p>&nbsp;</p>
      </div>
    </div>
  </body>
</html>
