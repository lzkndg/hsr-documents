\section{Week 2 Monitor Synchronization}

Race Condition: 2 Threads try to update the same shared (on heap) resource. 
Outcome: either one of the threads can write, the other update gets lost.

\verb|this.balance += amount| gets converted into three separate instructions. They will not be executed atomically.

Synchronization: restriction of concurrency.

Critical section: only one thread at a time can enter and execute this part of the code.

\subsection*{Synchronized Methods with Monitor}
Java: Keyword \verb|synchronized| in a method header guarantees that the method body is executed atomically.

Every object has a (Monitor-) Lock, which is acquired when any synchronized method is accessed. \verb|static| methods acquire the class objects lock which there is only one of.

Internal mutual exclusion, only one thread operates at a time. all not-private methodsa re synchronized

Wait \& Signal Mechanism: Outer waiting room to acquire Monitor Lock. Inner Waiting Room to wait for condition to be fulfilled.

Two methods: \verb|wait();| for condition, and \verb|notifyAll();| if something in a variable has changed.

Monitor Lock is only freed on method end, not notify/All.

\verb|notifyAll()| if the balance on bank account is increased by a deposit, every withdrawing thread should check their condition again, not just one.. 

\verb|notify()| is enough, if two conditions are fulfilled:\\
\begin{itemize}
    \item Uniform waiting condition (boolean): a change in the condition interests every waiting thread 
    \item One in one out: only a single waiting thread can continue
\end{itemize}

while loop: Check should happen every time the thread has access to the Monitor, not just the first time. Thread execution continues from where it has left off.

Spurious Wakeup: thread wakes up out of a special reason, maybe woken by the OS.

\subsection{Discussion}

Advantage: very powerful concept, object oriented\\

\noindent
Disadvantage: not always optimal. efficiency and fairness problems