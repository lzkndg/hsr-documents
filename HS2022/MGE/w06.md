# Android Architektur und Fortgeschrittenes

## Software-Architektur

Zerlegung grösserer Systeme in Teile verbessert Wartbarkeit und Verständlichkeit. **Schichten** gruppieren zusammengehörige Konzepte. Keine Zyklen wenn Abhängigkeiten nur nach unten zeigen. Presentation-Schicht beinhaltet Darstellung und Benutzerinteraktion, stark an UI-Tools gebunden. Domain-Schicht beinhaltet Businesslogik und Domänenklassen. Keine UI Funktionalität, einfach zu testen. Wenig externe Abhängigkeiten. Datenschicht dient der Speicherung, Bereitstellung von Daten. Auch Persistenz oder Datenhaltung genannt. **Variationen**: Mehr als 3 Schichten, zusätzlich vertikale Zerlegung nach Feature, Presentation Patterns (MVC, MVP, MVVM)

<img src="res/schichten.png" alt="Schichten" style="zoom:67%;" />

Fundament der Software soll nicht Daten sein, sondern Domäne. In der neueren (Clean Code-) **Ringarchitektur** ist auch die Datenbank in der äussersten Schicht, ändert also potenziell oft. Je weiter innen, desto stabiler. "Technische Details" sind aussen. Domäne bildet den Kern.

<img src="res/clean_code.png" alt="Ringe" style="zoom:50%;" />

**Ziele in MGE**: UI Code gruppieren, von restlichem Code trennen und bestmöglich testbar machen.

## Observer Pattern

Dient der "Rückmeldung" von Domain zu Presentation bei Änderungen an den Daten. **Subject/Observable**: Das Ding, das ändern kann, also innerhalb der Domäne. Bietet `Attach()/Detach()`-Funktionen. Eine `Notify()` Funktion führt `Update()` auf allen registrierten **Observern** (GUI-Elementen) aus. Ergo: Observer kennt Subject, umgekehrt nicht. *Wichtig*: Anmelden wenn die App sichtbar ist (`onResume`), abmelden wenn die App im Hintergrund ist (`onPause`). Ansonsten werden unnötige Ressourcen verschwendet, GUI aktualisiert das nicht sichtbar ist. 

![](res/android-observerpattern.png)

Grundlegend "manuelle" Implementation für jedes Objekt, komplex und aufwändig. Wer observiert Wen? An-/Abmelden korrekt überall? Vereinfachte, allgemeine Implementation nötig...

## Grundlagen Architektur

<img src="res/mvc.png" alt="MVC" style="zoom:50%;" /> <img src="res/mvp.png" alt="MVP" style="zoom:50%;" /><img src="res/mvvm.png" alt="MVVM" style="zoom:50%;" />

**Model View Controller**: Basis (lose) für Android. Kritik: Controller (Activity/Fragments) wird schnell extrem umfangreich und schwierig zu testen wegen Referenzen auf UI. **Model View Presenter:** Keine Verbindung zwischen View und Model. **Model View ViewModel:** Siehe Woche 7.

## Android: Application

Wird im AndroidManifest als `<application>` - Knoten definiert. Instanz wird beim Start der App erstellt - lebt solange die App läuft. Aufbau nach Standard oder selber definiert als abgeleitete Klasse. Kann verwendet werden für einmalige Initialisierungen, erzeugen von Singleton Objekten, Zugriff / Halten von globalen Objekten etc. Hat verschiedene Lifecycle-Methoden wie 
`onCreate, onTerminate` (wird NIE aufgerufen), 
`onConfigurationChanged(newConfig)` bei Änderungen der System-Konfig wie Sprache, Rotation des Geräts, 
`onLowMemory` bei Speicherknappheit, Hinweis auf mögliche Terminierung der App, 
`onTrimMemory(level)` in geeigneten Momente für Aufräumaktion, Parameter gibt Hinweis auf Auslöser.

```xml
<application android:name=".MyApplication"> <!-- Unsere Activities etc..  --> </application>
```

`Application.ActivityLifecycleCallbacks` ist ein Interface, dass implementiert werden kann um von allen Activities die Lifecycle-Events zentral verwalten zu können. Bietet überschreibbare Methoden wie `onActivityCreated()` mit der auslösenden Activity im Parameter. Gut für zentrales Logging etc.

```java
public class MyApplication extends Application implements Application.ActivityLifecycleCallbacks
{
    @Override public void onCreate() { 
	    super.onCreate();
        registerActivityLifecycleCallbacks(this); 	// Wichtig!
    }
    @Override public void onActivityCreated(Activity activity) { /* ... */ }
}
```

## Context

Abstrakte SDK Klasse mit vielen (50+) Ableitungen. Ermöglicht den **Zugriff auf Dienste und Ressourcen** der App. Verschiedene Ableitungen haben verschiedene Möglichkeiten. Activity hat andere "Berechtigungen" als Application. Lebensdauer des Context hängt vom aufrufenden Objekt ab, angeforderte Ressourcen werden wiederum mit dem zugehörigen Context freigegeben. **Vorsicht** beim Weitergeben von Context zwischen verschiedenen Activities etc.. 

<img src="res/context-overview.png" alt="Context table" style="zoom:50%;" />

## Brodacasts

**Global:** Austausch von Meldungen zwischen Apps. Datenquelle meist Android (auch eigene App möglich). Empfänger verschiedene Apps, die sich registrieren. **Beispiel**: Netzwerkverbindung verloren, SMS empfangen, ...

**Lokal**: Innerhalb App. Bsp. zum Senden von Benachrichtigung, die via Android OS wieder zurück kommt und von einer komplett separaten Komponente verarbeitet werden kann.

Wichtig: keinen sensitiven Daten übermitteln, App-ID integrieren.

Ableiten von Basisklasse Broadcast, Registrieren der Klasse im Manifest auf bestimmte Nachrichten.

## Services

Ausführen von Aktionen im Hintergrund. Lebenszyklus unabhängig von Activities.

Started Services haben eine klar definierte Lebensdauer (Download: klares Ende). UI nur innerhalb einer Notification (Foreground) oder gar keines (Background).

Bound Services leben so lange, wie sie verwendet werden (Musikplayer).
Können von verschiedenen Apps oder Aktivities gesteuert werden.

## Deployment

Package Dateien:

- .apk - Android Package
- .aab - Android App Bundle

Aus dem aab File wird auf den Google Servern bei Download das passende APK generiert.

Privater Schlüssel zur Signierung der App -> Für Updates im App Store zwingend nötig.

Google Play Store setzt Limit bei 100 MB.

Möglichkeiten:

- APK Splitting
- APK Expansion Files

AAB files: Vorteil, der Schlüssel liegt bei Google - Nachteil, der Schlüssel liegt bei Google..

DEX Format: Optimierte Bytecode-Sprache für Mobile-CPUs
