<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <title>w02</title>
  </head>
  <body class="typora-export os-windows">
    <div class="typora-export-content">
      <div id="write" class="">
        <h1 id="android-grundkonzepte"><span>Android Grundkonzepte</span></h1>
        <p>
          <span
            >Apps bestehen aus lose gekoppelten, wiederverwendbaren Komponenten
            wie </span
          ><em
            ><span
              >Activities, Content Providers, Services und Broadcast Receivers,
              etc.</span
            ></em
          ><span> </span><strong><span>Lebenszyklus</span></strong
          ><span>: vom OS verwaltet, kann App jederzeit terminieren. </span
          ><strong><span>Kommunikation</span></strong
          ><span> zwischen Komponenten/Apps evenfalls nur via OS. </span>
        </p>
        <p>
          <img
            src="res/android-app-struktur.png"
            referrerpolicy="no-referrer"
          />
        </p>
        <h2 id="activity"><span>Activity</span></h2>
        <p>
          <em><span>= eine Aufgabe</span></em
          ><span
            >. Besitzt eine graphische Oberfläche und verarbeitet
            Benutzereingaben. Main Activity wird beim App-Start ausgeführt. Muss </span
          ><strong><span>im Manifest registriert</span></strong
          ><span> werden. Bei Activity Start wird </span
          ><strong><span>XML verknüpft</span></strong
          ><span>: </span
          ><code>onCreate () { setContentView( R.layout.activity_main ); }</code
          ><span>. Ereignisse im XML File werden via </span
          ><strong><span>Listener</span></strong
          ><span> verarbeitet. </span><strong><span>Zustände</span></strong
          ><span>
            und Callbacks bei Zustands-Wechseln. Methoden werden bei Bedarf
            überschrieben. </span
          ><strong><span>Zustände</span></strong
          ><span
            >: Created &gt;&gt; Started &gt;&gt; Paused &gt;&gt; Resumed
            &gt;&gt; Stopped &gt;&gt; Destroyed. </span
          ><strong><span>Callbacks</span></strong
          ><span
            >: onCreate, onStart, onRestart, onResume, onPause, onStop,
            onDestroy.</span
          >
        </p>
        <p>
          <span>Typisch: </span><strong><span>Datensicherung</span></strong
          ><span> bei </span><code>onPause()</code><span> oder </span
          ><code>onStop()</code><span>, </span
          ><strong><span>Dienste</span></strong
          ><span> ein-/ausschalten bei </span><code>onResume/onPause</code
          ><span>
            (oder: Lifecycle-aware components), Zustand des GUI erhalten bei </span
          ><code>onSaveInstanceState/onRestoreInstanceState</code
          ><span> (oder: ViewModel).</span>
        </p>
        <h2 id="event-handling"><span>Event Handling</span></h2>
        <p>
          <span
            >Basic: Listener reagieren auf Ereignisse im GUI, wenn registriert.
            Objektreferenzen abholen via findViewById(int). Je nach Event-Typ
            und View Item unterschiedliche Interfaces, die überschrieben werden
            können.</span
          >
        </p>
        <pre
          class="md-fences md-end-block ty-contain-cm modeLoaded"
          spellcheck="false"
          lang="java"
        ><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Button</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-variable">findViewById</span>(<span class="cm-variable">R</span>.<span class="cm-variable">id</span>.<span class="cm-variable">button_example</span>);</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">button</span>.<span class="cm-variable">setOnClickListener</span>(<span class="cm-keyword">new</span> <span class="cm-variable">View</span>.<span class="cm-variable">OnClickListener</span>() { <span class="cm-meta">@Override</span> <span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">onClick</span>(<span class="cm-variable">View</span> <span class="cm-variable">view</span>) {}});</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 52px;"></div><div class="CodeMirror-gutters" style="display: none; height: 52px;"></div></div></div></pre>
        <h2 id="resources"><span>Resources</span></h2>
        <p>
          <span>Werden im Java Code über die </span
          ><strong><span>R-Klasse</span></strong
          ><span>
            angesprochen, die wird beim Build erzeugt und ist mit Namespaces
            strukturiert. Resource ID als </span
          ><code>int</code><span>. Enthält Layouts, Bilder, Videos, ... </span
          ><strong><span>Value Resources</span></strong
          ><span>
            werden in einzelnen Files nach Typen gruppiert: Farbwerte,
            Dimensionen, Texte, Styles. </span
          ><strong><span>Qualifiers</span></strong
          ><span>
            im Dateinamen können verwendet werden, um spezifisch auf Endgerät
            verschiedene Informationen zu laden. Unterscheidung nach Sprachen,
            Auflösungen, Gerätetypen, API-Versionen etc..</span
          >
        </p>
        <h2 id="dimensionen"><span>Dimensionen</span></h2>
        <p>
          <strong><span>dp</span></strong
          ><span>: density-independent pixel (für fast alles), </span
          ><strong><span>sp</span></strong
          ><span>: scale-independent pixel für schriften</span>
          <strong><span>px/pt</span></strong
          ><span>: pixel/punkte (nie), </span><strong><span>in/mm</span></strong
          ><span>: inch / millimeter (auch nie..)</span>
        </p>
        <h2 id="manifest"><span>Manifest</span></h2>
        <p>
          <strong><span>Inhalt:</span></strong
          ><span>
            alle Informationen die Android braucht, um die App installieren und
            darstellen zu können. d.h.
          </span>
          <span>App-ID/Name (</span
          ><code>package=&quot;dev.kuendig.choirmate&quot;</code
          ><span>: eindeutige Id, definiert Namespace)</span>
          <span>Version </span><em><span>(aus build.gradle ergänzt)</span></em
          ><span> (</span><em><span>versionName</span></em
          ><span>: lesbar / </span><em><span>versionCode</span></em
          ><span>: positiver Int) und Logo, min- und targetsdkVersion </span
          ><em><span>(build.gradle)</span></em
          ><span
            >, enthaltene Komponenten, Hard- und Softwareanforderungen,
            benötigte Berechtigungen.
          </span>
        </p>
        <h2 id="intents"><span>Intents</span></h2>
        <p>
          <span
            >Dienen zur Kommunikation zwischen Komponenten, wechseln zwischen
            Activities. </span
          ><strong><span>Expliziter</span></strong
          ><span>
            Intent: Zeige einen spezifischen Screen, normal eigene App. </span
          ><strong><span>Impliziter</span></strong
          ><span>
            Intent: Zeige eine passende Komponente für die aktuelle Aktion,
            normal fremde App. Registrieren auf implizite Intents im Manifest.
            Bei Verwendung immer erst prüfen, ob eine passende App vorhanden ist
            mit </span
          ><code
            >bool hasReceiver = intent.resolveActivity(getPackageManager()) !=
            null;</code
          ><span> .</span><br /><span>Benötigt </span
          ><code
            >&lt;uses-permission
            android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot;
            /&gt;</code
          ><span> im Manifest.</span>
        </p>
        <p>
          <span>Ziel des Intents definieren mit </span
          ><code>intent.setData(&quot;Uri:Datei/webseite/telnr/...&quot;)</code
          ><span>, </span
          ><code
            >startActivity(Intent)`` Wenn der Intent ein Resultat zurückliefert:
            ``startActivityForResult(Intent)</code
          ><span>.</span>
          <span
            >Übergeben von Daten via Extras (primitive Types, String und
            serialisierbare Objekte): </span
          ><code>intent.putExtra(&quot;solution&quot;, 42);</code
          ><span> Kommunikation mit anderen Komponenten möglich (W06).</span>
        </p>
        <h2 id="tasks--back-stacks-prozesse-threads">
          <span>Tasks / Back Stacks, Prozesse, Threads</span>
        </h2>
        <p>
          <span
            >Alle ausgeführten Activites werden in einem Back Stack bzw. Task
            verwaltet (Overview Screen zeigt die verschiedenen offenen Tasks).
            Activities innerhalb Task können mehrfach vorhanden sein oder auch
            zu verschiedenen Apps gehören. Acitivities können auch in neuen
            Tasks gestartet werden. Jede App / APK wird mit einem eigenen
            Linux-User installiert (Sandbox Prinzip). APK hat genau 1 eigenen </span
          ><strong><span>Prozess</span></strong
          ><span>, darin mind. den Main-</span
          ><strong><span>Thread</span></strong
          ><span>
            und evtl. weitere Threads. Blockieren des Main-Trheads führt zum
            Application Not Responding (</span
          ><strong><span>ANR</span></strong
          ><span
            >-) Screen. GUI-Aktualisierung nur aus Main-Thread möglich,
            langlaufende Operationen immer in anderen Thread (Runnable,
            (Coroutine?)) auslagern.</span
          >
        </p>
        <p>
          <span>Optionen zur GUI-Aktualisierung: </span
          ><code>Activity.runOnUiThread(Runnable)</code><span>, </span
          ><code>View.post(runnable)</code><span>, </span><code>Handler</code
          ><span> und </span><code>Looper</code>
        </p>
        <h2 id="rückwärtskompatibilität">
          <span>Rückwärtskompatibilität</span>
        </h2>
        <p>
          <span
            >API Level identifiziert die Android API Version. Höhere Levels
            enthalten immer alle tieferen, aber ggf. als deprecated markiert. </span
          ><strong><span>Trade Off</span></strong
          ><span
            >: niedrig um alle Geräte zu erreichen, hoch um die neuen Funktionen
            nutzen zu können. Werte in Manifest bzw. Gradle:</span
          >
        </p>
        <p>
          <code>minSdkVersion</code
          ><span>: ältere Geräte können meine App nicht nutzen. </span
          ><code>maxSdkVersion</code
          ><span
            >: Wird von Android ignoriert, von Google Play Store als Filter
            verwendet. Empfehlung: ignorieren. </span
          ><code>targetSdkVersion</code
          ><span
            >: gibt an, auf welche Version die App getestet ist und sicher
            stabil läuft. </span
          ><code>compileSdkVersion</code
          ><span
            >: gibt an, mit welcher API die App kompiliert wird/wurde.</span
          >
          <span>Ziel: </span
          ><code>minSdk &lt;= targetSdk &lt;= compileSdk</code>
        </p>
        <p>
          <span
            >Wird Code eines API Level verwendet, der höher ist als die
            minSdkVersion, muss auf dem Gerät ein </span
          ><strong><span>Versionscheck</span></strong
          ><span>
            gemacht und ein Fallback definiert werden. Um das zu vermeiden, gibt
            es </span
          ><strong><span>Android Jetpack / AndroidX</span></strong
          ><span
            >. Erweitert die Android SDK, wird unabhängig von Android
            entwickelt. Eigene Versionierung. Verwendete Klassen müssen nur
            erben von Komponenten der AppCompat Jetpack-Library. </span
          ><code>AppCompatActivity</code><span> statt </span
          ><code>Activity</code><span>, </span><code>AppCompatButton</code
          ><span> statt </span><code>Button</code
          ><span
            >, etc etc. Hiess früher Android Support Libraries, Namespace ist </span
          ><code>androidx</code
          ><span
            >. Integration durch Android Studio automatisch in neuen
            Projekten.</span
          >
        </p>
        <p>&nbsp;</p>
      </div>
    </div>
  </body>
</html>
