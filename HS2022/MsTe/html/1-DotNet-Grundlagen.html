<!doctype html>
<html>
<head>
  <meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <title>1-DotNet-Grundlagen</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''>
  <h1 id='net-grundlagen'><span>.NET Grundlagen</span></h1>
  <h2 id='net-geschichte'><span>.NET Geschichte</span></h2>
  <p><img src=".\res\dot-net-core.png" alt=".NET Core History" /></p>
  <ul>
    <li><p><strong><span>.NET Framework</span></strong><span>: nicht mehr weitergeführt. Bis 2019 mit Version 4.8</span></p></li>
    <li><p><strong><span>.NET Core</span></strong><span>: Multiplatform Implementierung, existiert ab 2016, heisst ab 2020 nur noch .NET und löst Framework ab</span></p></li>
    <li><p><strong><span>.NET Standard</span></strong><span>: Bietet eine einheitliche Base Class Library (Standard API) für verschiedene Implementationen (Framework, Core, Xamarin, ...). Jede Implementation verwendet eine gewisse .NET Standard Version. </span></p>
      <ul>
        <li><span>Ziel: Konsistenz und implementation &quot;neutraler&quot; cross-platform Libraries.</span></li>
        <li><span>Kompatibilität mit jeweils verwendeter Core / Framework Version muss gegeben sein.</span></li>
        <li><span>Bei Verwendung in eigenen Libraries: je tiefer die .NET Standard Version, desto einfacher einzubinden, aber desto weniger API Funktionen zur Verfügung.</span></li>
      </ul>
    </li></ul>
<h2 id='net-architektur'><span>.NET Architektur</span></h2>
<p><img src=".\res\dot-net-architektur.png" alt=".NET Architektur" /></p>
<h2 id='common-language-runtime-clr'><span>Common Language Runtime (CLR)</span></h2>
<p><span>Laufzeitumgebung für .NET Code, analog Java Virtual Machine JVM</span></p>
<ul><li><span>JIT Compiler (Just-In-Time) übersetzt IL Code in Maschinencode</span></li>
  <li><span>Speicherverwaltung mit Garbage Collection</span></li>
<li><span>Common Language Specification CLS: ermöglicht cross-language development dank MSIL, sprachübergreifendes Debugging, Type Checking und Code Verification der MSIL (Intermediate Language)</span></li>
  <li><span>Common Type System CTS</span></li>
<li><span>Class Loader lädt Klassen-Code zur Laufzeit</span></li>
  <li><span>Code Access Security</span></li>
  <li><span>Exceptions</span></li>
<li><span>Thread-Verwaltung</span></li>
  <li><span>COM-Interoperabilität (Interaktion mit unmanaged Code)</span></li>
</ul>
<p><img src=".\res\dot-net-clr.png" alt=".NET Common Language Runtime Architektur" /></p>
<h3 id='microsoft-intermediate-language--msil'><span>Microsoft Intermediate Language  (MSIL)</span></h3>
<p><span>MSIL ist eine vorkompilierte Zwischensprache, und beinhaltet das Common Type System CTS. Sie ist</span></p>
<ul><li><span>Prozessor-unabhängig bzw. Plattformneutral und dadurch portabel</span></li>
  <li><span>Assembler-ähnlich</span></li>
<li><span>Sprach-Unabhängig innerhalb der .NET Familie</span></li>
  <li><span>Typsicher (Type- und weitere Security-Checks beim Laden des Codes)</span></li>
  <li><span>Nachteil Effizienz (wird durch JIT teils wettgemacht, der zur Laufzeit spezifische Maschineninstruktionen nutzen kann)</span></li>
</ul>
<p><img src=".\res\dot-net-msil.png" alt=".NET Common Language Runtime Architektur" /></p>
<h3 id='just-in-time-compilation-jit'><span>Just in Time Compilation (JIT)</span></h3>
<p><img src=".\res\dot-net-jit.png" alt=".NET JIT Compiler" /></p>
<p><span>Drei Typen der Kompilierung</span></p><ul><li><span>Pre-JIT: Alles vor Ausführung kompiliert</span></li>
  <li><span>Normal-JIT: Kompilierung von Methoden bei Aufruf</span></li>
  <li><span>Econo-JIT: Wie Normal aber mit Cleanup-Mechanismus</span></li>
</ul>
<h3 id='common-type-system-cts'><span>Common Type System (CTS)</span></h3>
<p><span>Das einheitliche Typensystem der .NET Umgebung ist in der CLR integriert, somit losgelöst von der einzelnen Programmiersprache. Das Typsystem ist Single-Rooted - das heisst alles ist von </span><code>System.Object</code><span> abgeleitet, auch alle Primitivtypen.</span></p>
<p><span>Reference Types sind alle gängigen Objekte, Klassen etc. (auch Strings), Value Types sind alle Basistypen: </span><em><span>sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, bool, char</span></em></p>
<p><img src=".\res\dot-net-datatypes.jpg" alt=".NET Types" /></p>
<p><span>Polymorphismus ist somit für ausnahmslos alle Typen möglich. Methode, die </span><code>System.Object</code><span> erwartet, kann einen &quot;normalen&quot; Int annehmen.</span></p><h4 id='reference-types'><span>Reference Types</span></h4><p><code>Class</code><span> erzeugt einen eigenen Reference Type. Auf dem Stack wird ein Pointer angelegt, der auf das effektive Objekt im Heap zeigt.</span></p>
<p><code>null</code><span> beschreibt immer eine Referenz ohne Adresse / Ziel.</span></p>
<p><span>Beinhaltet auch immer eine Referenz auf den Typen. </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="csharp"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="csharp"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">class</span> <span class="cm-def">PointRef</span> { <span class="cm-keyword">public</span> <span class="cm-variable-3">int</span> <span class="cm-variable">X</span>, <span class="cm-variable">Y</span>; }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PointRef</span> <span class="cm-variable">a</span>; <span class="cm-comment">// erzeugt im Stack eine leere Referenz</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PointRef</span>(); <span class="cm-comment">// definiert die Referenz im Stack, erzeugt auf dem Heap ein leeres Objekt (Default-Initialisierung von Value Types)</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">X</span> <span class="cm-operator">=</span> <span class="cm-number">12</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">Y</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>; <span class="cm-comment">// jeweiliger Speicherbereich im Heap wird angepasst</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 156px;"></div><div class="CodeMirror-gutters" style="display: none; height: 156px;"></div></div></div></pre><p><span>Zuweisung: Objekt-Referenz wird kopiert. Anpassung an einem Objekt verursacht auch änderungen am anderen Objekt.</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="csharp"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="csharp"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PointRef</span> <span class="cm-variable">a</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PointRef</span>();</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">X</span> <span class="cm-operator">=</span> <span class="cm-number">12</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">Y</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PointRef</span> <span class="cm-variable">b</span> <span class="cm-operator">=</span> <span class="cm-variable">a</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">b</span>.<span class="cm-variable">X</span> <span class="cm-operator">=</span> <span class="cm-number">9</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Console</span>.<span class="cm-variable">WriteLine</span>(<span class="cm-variable">a</span>.<span class="cm-variable">X</span>); <span class="cm-comment">// Gibt 9 aus</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 156px;"></div><div class="CodeMirror-gutters" style="display: none; height: 156px;"></div></div></div></pre><p>&nbsp;</p><h4 id='value-types'><span>Value Types</span></h4><p><code>Struct</code><span> erzeugt einen eigenen Value Type. Das Objekt liegt direkt auf dem Stack, </span><strong><span>oder inline im Reference- oder Value Type.</span></strong></p>
<p><span>Konstruktor wird vom Compiler automatisch generiert, macht Default-Initialisierung (ausnulle des Speichers). Structs können nicht abgeleitet werden (sealed).</span></p>
<p><code>null</code><span> bei Value Types wird immer mit 0 oder false oder der Default-Wert verwendet. Effektiver </span><code>null</code><span>- Wert nicht möglich.</span></p>
<p><span>Vorteile:</span></p><ul><li><span>effiziente Speicherausnutzung</span></li>
<li><span>effizienter Zugriff</span></li>
<li><span>keine Garbage Collection nötig, wird nach Ende der Methode abgeräumt</span></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="csharp"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="csharp"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">struct</span> <span class="cm-def">PointVal</span> { <span class="cm-keyword">public</span> <span class="cm-variable-3">int</span> <span class="cm-variable">X</span>, <span class="cm-variable">Y</span>; }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PointVal</span> <span class="cm-variable">a</span>; <span class="cm-comment">// Im Speicher noch nichts passiert</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PointVal</span>(); <span class="cm-comment">// Speicher auf dem Stack wird alloziiert und Default-Initialisiert</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">X</span> <span class="cm-operator">=</span> <span class="cm-number">12</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span>.<span class="cm-variable">Y</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>; <span class="cm-comment">// Werte auf dem Stack werden angepasst</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 130px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre><p><span>Zuweisung: gesamter Wert auf dem Stack wird kopiert. </span></p><figure><table><thead><tr><th><span>Keyword</span></th><th><span>Aliased Type</span></th><th><span>Java</span></th><th><span>Wertebereich</span></th></tr></thead><tbody><tr><td><span>sbyte</span></td><td><span>System.SByte</span></td><td><span>byte</span></td><td><span>-128 .. 127</span></td></tr><tr><td><span>byte</span></td><td><span>System.Byte</span></td><td>&nbsp;</td><td><span>0 .. 255</span></td></tr><tr><td><span>short</span></td><td><span>System.Int16</span></td><td><span>short</span></td><td><span>-32&#39;768 .. 32&#39;767</span></td></tr><tr><td><span>ushort</span></td><td><span>System.UInt16</span></td><td>&nbsp;</td><td><span>0 .. 65&#39;535</span></td></tr><tr><td><span>int</span></td><td><span>System.Int32</span></td><td><span>int</span></td><td><span>-2&#39;148&#39;483&#39;648 .. 2&#39;147&#39;483&#39;647</span></td></tr><tr><td><span>uint</span></td><td><span>System.UInt32</span></td><td>&nbsp;</td><td><span>0 .. 4&#39;294&#39;967&#39;295</span></td></tr><tr><td><span>long</span></td><td><span>System.Int64</span></td><td><span>long</span></td><td><span>-2^63 .. 2^63-1</span></td></tr><tr><td><span>ulong</span></td><td><span>System.UInt64</span></td><td>&nbsp;</td><td><span>0 .. 2^64-1</span></td></tr><tr><td><span>char</span></td><td><span>System.Char</span></td><td><span>float</span></td><td><span>+- 1.5E-45 .. +- 3.4E38 (32bit)</span></td></tr><tr><td><span>float</span></td><td><span>System.Single</span></td><td><span>double</span></td><td><span>+- 5E-324 .. +- 1.7E308 (64bit)</span></td></tr><tr><td><span>double</span></td><td><span>System.Double</span></td><td>&nbsp;</td><td><span>+- 1E-28 .. +- 7.9E28 (128bit)</span></td></tr><tr><td><span>bool</span></td><td><span>System.Boolean</span></td><td><span>boolean</span></td><td><span>true, false</span></td></tr><tr><td><span>decimal</span></td><td><span>System.Decimal</span></td><td><span>char</span></td><td><span>Unicode-Zeichen</span></td></tr></tbody></table></figure><h4 id='boxing--unboxing'><span>Boxing / Unboxing</span></h4><p><span>Beschreibt das automatische umwandeln von Value Types in Reference Types und zurück. Immer dann, wenn ein Value Type (Struct) als Instanz einem Reference Type zugewiesen wird.</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="csharp"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="csharp"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">System</span>.<span class="cm-variable-3">Int32</span> <span class="cm-variable">i1</span> <span class="cm-operator">=</span> <span class="cm-number">12</span>; <span class="cm-comment">// Value Type</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">System</span>.<span class="cm-variable-3">Object</span> <span class="cm-variable">obj</span> <span class="cm-operator">=</span> <span class="cm-variable">i1</span>; <span class="cm-comment">// Implizites Boxing zum Reference Type</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">System</span>.<span class="cm-variable-3">Int32</span> <span class="cm-variable">i2</span> <span class="cm-operator">=</span> (<span class="cm-variable">System</span>.<span class="cm-variable-3">Int32</span>)<span class="cm-variable">obj</span>; <span class="cm-comment">// Unboxing muss explizit gecastet werden</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><h2 id='assemblies'><span>Assemblies</span></h2><p><span>Ergebnis der Kompilation, eine Deployment- oder Ausführungseinheit. Vom Typ Executable (</span><code>*.exe</code><span>) oder Library (</span><code>*.dll</code><span>). Können dynamisch geladen werden, definiert Typ-Scope. Kleinste versionierbare Einheit. Entspricht einem JAR-File in Java. </span></p>
<p><img src=".\res\dot-net-assembly.png" alt=".NET JIT Compiler" style="zoom: 33%;" /></p><h4 id='module-und-metadata'><span>Module und Metadata</span></h4><p><span>Enthält Code (MSIL) und Metadaten. Metadaten enthalten alle Aspekte des Codes ausser Programmlogik (Definitionen von Klassen, Methoden, Feldern etc.) und können mittels Reflection abgefragt werden. </span></p><ul><li><span>Anwendungen in der CLR: Typsicherheit, Memory Management, JIT Compilation</span></li>
<li><span>Anwendungen der IDE: Object-Browser, IntelliSense</span></li>
<li><span>Tools zur Analyse: IL Disassembler (IL DASM), viele Drittanbietertools</span></li>
<li><span>Erweiterbare Programmsysteme (Generische Ansätze, Dynamic Binding)</span></li></ul><h2 id='net-class-library'><span>.NET Class Library</span></h2><ul><li><span>Basisklassen mit System-Funktionen</span></li>
<li><span>ADO.NET / Entity Framework für DB-Zugriff</span></li>
<li><span>ASP.NET (Core) Web-Programmierung</span></li>
<li><span>XML, Dateisystemzugriff</span></li>
<li><span>WPF und Windows Forms (GUI)</span></li></ul><h2 id='cli-interface'><span>CLI Interface</span></h2><p><span>Teil des .NET Core SDK dient als Basis für high-level Tools wie IDEs. Command Struktur lautet ähnlich wie Git:</span></p>
<p><code>dotnet[.exe] &lt;verb&gt; &lt;argument&gt; --&lt;option&gt; &lt;param&gt;</code><span> -- Argument zum Verb (eines), Parameter zur Option (0-n). </span></p>
<p><span>Möglichkeiten (Auszug):</span></p>
<p><img src=".\res\dot-net-cli.png" alt=".NET JIT Compiler" style="zoom: 33%;" /></p><h2 id='projekte--referenzen'><span>Projekte &amp; Referenzen</span></h2><p><span>Projekt-Datei wird seit Version 1.0 als XML verwaltet (</span><code>*.csproj</code><span> neu seit 2017). Build Engine von Microsoft heisst </span><code>MSBuild</code><span>, kann direkt oder auch via .NET CLI verwendet werden.</span></p><ul><li><code>&lt;Property*&gt;</code><span>: Settings</span></li>
<li><code>&lt;Item*&gt;</code><span>: zu kompilierende Items</span></li>
<li><code>&lt;Target*&gt;</code><span>: Sequenz auszuführender Schritte, TargetFramework definiert die zu kompilierende Ziel-API.</span></li></ul><p><span>Alte Variante vor 2017 war extrem gross und sperrig. Betreffen nur .NET Framework 4.8 und älter.</span></p>
<p><span>Referenzen können im Projekt auf verschiedene Arten geführt werden.</span></p><ul><li><span>Vorkompiliertes Assembly: Muss im File System verfügbar sein</span></li>
<li><span>NuGet Package: Externe Dependency (nuget.org)</span></li>
<li><span>Visual Studio Projekt: in selber Solution vorhanden</span></li>
<li><span>.NET Core oder Standard SDK (default, zwingend: </span><code>Microsoft.NETCore.App</code><span> oder </span><code>NETStandard.Library</code><span>)</span></li></ul><h2 id='nuget-packages'><span>NuGet Packages</span></h2><p><span>Neuer Standard für Packagin von Applikationen. Teilt die .NET Funktionalität in verschiedene kleinere Packages auf. Erlaubt unterschiedliche Release-Zyklen, erhöht die Kompatibilität durch Kapselung von spezifischen Komponenten, verkleinert die Deployment-Einheiten.</span></p>
<p><span>Der Dateityp </span><code>*.nupkg</code><span> (zip) beinhaltet Assemblies, Manifest mit Infos zu Package Id, Titel und Beschreibung, Versions-Informationen, Dependencies etc.</span></p>
<p><span>Ablauf mit Kompilierung (</span><code>dotnet build</code><span>), Paketierung (</span><code>dotnet pack</code><span>), Veröffentlichung (</span><code>dotnet nuget push</code><span>), Konsumation (</span><code>dotnet add package</code><span>).</span></p>
<p><span>Wichtige Packages sind</span></p><ul><li><code>System.Runtime</code><span> (Object, String, Array, Action, Func, ...)</span></li>
<li><code>System.Collections</code><span> (Generische Listen wie List</span><T><span>, Dictionary&lt;TKey, TValue&gt;, ...)</span></li>
<li><code>System.Net.Http</code><span> (HttpClient, HttpResponseMessage, ...)</span></li>
<li><code>System.IO.FileSystem</code><span> (File, Directory, ...)</span></li>
<li><code>System.Linq</code><span> (Enumerable, ILookup&lt;TKey, TElement&gt;, ...)</span></li>
<li><code>System.Reflection</code><span> (Assembly, TypeInfo, MethodInfo, ...)</span></li></ul><h2 id='net-standard'><span>.NET Standard </span></h2><p><span>Wurde mit .NET Core eingeführt, diente als Brücke zwischen .NET Framework und .NET Core. Motivation: </span></p><ul><li><span>Implementation von &quot;neutralen&quot; Libraries für Cross-Platform Entwicklung. Können von Core und Framework verwendet werden. Base Class Libraries, Beispiel: Zugriff Filesystem / Sockets, Serialisierung von XML, und und und...</span></li>
<li><span>Konsistenz zwischen verschiedenen Frameworks (Fragmentierung minimal halten)</span></li></ul><p><img src=".\res\dot-net-standard.png" alt=".NET JIT Compiler" style="zoom: 33%;" /></p>
<p><em><span>.NET Standard listet minimal zu unterstützende APIs (Klassen und Methoden) auf.</span></em></p>
<p><span>Kompatibilität: Jede .NET Implementation unterstützt eine maximale .NET Standard Version. </span></p>
<p><span>Bei eigenen Libraries: je höher die Version, desto mehr APIs können verwendet werden. Je tiefer, desto einfacher einzubinden.</span></p></div></div>
</body>
</html>